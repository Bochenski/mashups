// Generated by CoffeeScript 1.3.3
var BROWSER_OPTIONS, Browser, Cache, Cookies, Credentials, EventEmitter, EventLoop, FS, GLOBAL_OPTIONS, HTML, HTML5, Interact, JSDOM, MOUSE_EVENT_NAMES, Mime, PACKAGE, Path, Q, Resources, Storages, URL, VERSION, Windows, XHR, deprecated,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

require("./jsdom_patches");

require("./forms");

require("./xpath");

deprecated = require("./helpers").deprecated;

Cache = require("./cache");

Cookies = require("./cookies");

EventEmitter = require("events").EventEmitter;

EventLoop = require("./eventloop");

FS = require("fs");

HTML5 = require("html5").HTML5;

Interact = require("./interact");

JSDOM = require("jsdom");

Mime = require("mime");

Q = require("q");

Path = require("path");

Resources = require("./resources");

Storages = require("./storage");

URL = require("url");

Windows = require("./windows");

XHR = require("./xhr");

BROWSER_OPTIONS = ["debug", "headers", "htmlParser", "loadCSS", "maxWait", "proxy", "referer", "runScripts", "silent", "site", "userAgent", "waitFor", "name"];

GLOBAL_OPTIONS = ["debug", "headers", "htmlParser", "loadCSS", "maxWait", "proxy", "runScripts", "silent", "site", "userAgent", "waitFor"];

PACKAGE = JSON.parse(require("fs").readFileSync(__dirname + "/../../package.json"));

VERSION = PACKAGE.version;

HTML = JSDOM.dom.level3.html;

MOUSE_EVENT_NAMES = ["mousedown", "mousemove", "mouseup"];

Browser = (function(_super) {

  __extends(Browser, _super);

  function Browser(options) {
    var name, _i, _len,
      _this = this;
    if (options == null) {
      options = {};
    }
    this._cache = new Cache();
    this._cookies = new Cookies();
    this._eventloop = new EventLoop(this);
    this._storages = new Storages();
    this._interact = Interact.use(this);
    this._xhr = XHR.use(this._cache);
    this.on("error", function(error) {
      _this.errors.push(error);
      return _this.log(error.message, error.stack);
    });
    this.referer = void 0;
    this.name = "nodejs";
    for (_i = 0, _len = BROWSER_OPTIONS.length; _i < _len; _i++) {
      name = BROWSER_OPTIONS[_i];
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      } else if (~GLOBAL_OPTIONS.indexOf(name)) {
        this[name] = Browser[name];
      }
    }
    this._setCredentials(options.credentials || Browser.credentials);
    this.errors = [];
    this.resources = new Resources(this);
    this.windows = new Windows(this);
  }

  Browser.debug = false;

  Browser.htmlParser = HTML5;

  Browser.loadCSS = true;

  Browser.maxWait = "5s";

  Browser.proxy = null;

  Browser.runScripts = true;

  Browser.silent = false;

  Browser.userAgent = "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/" + VERSION;

  Browser.site = void 0;

  Browser.waitFor = "0.5s";

  Browser.headers = {};

  Browser.prototype.withOptions = function(options, fn) {
    var k, restore, v, _ref,
      _this = this;
    if (options) {
      restore = {};
      for (k in options) {
        v = options[k];
        if (~BROWSER_OPTIONS.indexOf(k)) {
          _ref = [this[k], v], restore[k] = _ref[0], this[k] = _ref[1];
        }
      }
      this._setCredentials(options.credentials);
      return function() {
        var _results;
        _results = [];
        for (k in restore) {
          v = restore[k];
          _results.push(_this[k] = v);
        }
        return _results;
      };
    } else {
      return function() {};
    }
  };

  Browser.prototype.fork = function() {
    var forked, name, _i, _len;
    forked = new Browser();
    forked.loadCookies(this.saveCookies());
    forked.loadStorage(this.saveStorage());
    forked.loadHistory(this.saveHistory());
    forked.location = this.location;
    for (_i = 0, _len = BROWSER_OPTIONS.length; _i < _len; _i++) {
      name = BROWSER_OPTIONS[_i];
      forked[name] = this[name];
    }
    return forked;
  };

  Browser.prototype.__defineGetter__("window", function() {
    return this.windows.current;
  });

  Browser.prototype.open = function(options) {
    this._eventloop.reset();
    this.errors = [];
    this.resources.clear();
    return this.windows.open(options || {});
  };

  Browser.prototype.__defineGetter__("error", function() {
    return this.errors[this.errors.length - 1];
  });

  Browser.prototype.wait = function(duration, callback) {
    var deferred, last, _ref,
      _this = this;
    if (arguments.length < 2 && typeof duration === "function") {
      _ref = [duration, null], callback = _ref[0], duration = _ref[1];
    }
    deferred = Q.defer();
    last = this.errors[this.errors.length - 1];
    this._eventloop.wait(this.window, duration, function(error) {
      var newest;
      newest = _this.errors[_this.errors.length - 1];
      if (!(error || last === newest)) {
        error = newest;
      }
      if (error) {
        deferred.reject(error);
      } else {
        deferred.resolve();
      }
      if (callback) {
        return callback(error);
      }
    });
    if (!callback) {
      return deferred.promise;
    }
  };

  Browser.prototype.fire = function(name, target, callback) {
    var event, type;
    type = __indexOf.call(MOUSE_EVENT_NAMES, name) >= 0 ? "MouseEvents" : "HTMLEvents";
    event = this.window.document.createEvent(type);
    event.initEvent(name, true, true);
    this.dispatchEvent(target, event);
    return this.wait(callback);
  };

  Browser.prototype.dispatchEvent = function(target, event) {
    return this._eventloop.dispatch(target, event);
  };

  Browser.prototype.queryAll = function(selector, context) {
    var ret;
    if (selector) {
      context || (context = this.document);
      ret = context.querySelectorAll(selector);
      return Array.prototype.slice.call(ret, 0);
    } else {
      context || (context = this.document.documentElement);
      return [context];
    }
  };

  Browser.prototype.query = function(selector, context) {
    context || (context = this.document);
    if (selector) {
      return context.querySelector(selector);
    } else {
      return context;
    }
  };

  Browser.prototype.$$ = function(selector, context) {
    return this.query(selector, context);
  };

  Browser.prototype.querySelector = function(selector) {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelector(selector) : void 0;
  };

  Browser.prototype.querySelectorAll = function(selector) {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelectorAll(selector) : void 0;
  };

  Browser.prototype.text = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function(e) {
        return e.textContent;
      }).join("").trim().replace(/\s+/g, " ");
    }
    return this.source;
  };

  Browser.prototype.html = function(selector, context) {
    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function(e) {
        return e.outerHTML.trim();
      }).join("");
    }
    return this.source;
  };

  Browser.prototype.css = function(selector, context) {
    deprecated("Browser.css is deprecated, please use browser.query and browser.queryAll instead.");
    return this.queryAll(selector, context);
  };

  Browser.prototype.xpath = function(expression, context) {
    return this.document.evaluate(expression, context || this.document.documentElement);
  };

  Browser.prototype.__defineGetter__("document", function() {
    var _ref;
    return (_ref = this.window) != null ? _ref.document : void 0;
  });

  Browser.prototype.__defineGetter__("body", function() {
    var _ref;
    return (_ref = this.window.document) != null ? _ref.querySelector("body") : void 0;
  });

  Browser.prototype.__defineGetter__("statusCode", function() {
    var _ref;
    return (_ref = this.response) != null ? _ref[0] : void 0;
  });

  Browser.prototype.__defineGetter__("success", function() {
    return this.statusCode >= 200 && this.statusCode < 300;
  });

  Browser.prototype.__defineGetter__("redirected", function() {
    var _ref, _ref1;
    return !!((_ref = this.resources.last) != null ? (_ref1 = _ref.response) != null ? _ref1.redirected : void 0 : void 0);
  });

  Browser.prototype.__defineGetter__("source", function() {
    var _ref;
    return (_ref = this.response) != null ? _ref[2] : void 0;
  });

  Browser.prototype.close = function() {
    var _results;
    _results = [];
    while (this.windows.current) {
      _results.push(this.windows.close());
    }
    return _results;
  };

  Browser.prototype.visit = function(url, options, callback) {
    var deferred, duration, reset_options, site, _ref, _ref1,
      _this = this;
    if (typeof options === "function" && !callback) {
      _ref = [options, null], callback = _ref[0], options = _ref[1];
    }
    if (typeof options !== "object") {
      _ref1 = [options, null], duration = _ref1[0], options = _ref1[1];
    }
    deferred = Q.defer();
    reset_options = this.withOptions(options);
    if (site = this.site) {
      if (!/^(https?:|file:)/i.test(site)) {
        site = "http://" + site;
      }
      url = URL.resolve(site, URL.parse(URL.format(url)));
    }
    this.window.history._assign(url);
    this.wait(duration, function(error) {
      reset_options();
      if (error) {
        deferred.reject(error);
      } else {
        deferred.resolve();
      }
      if (callback) {
        return callback(error, _this, _this.statusCode, _this.errors);
      }
    });
    if (!callback) {
      return deferred.promise;
    }
  };

  Browser.prototype.load = function(html, callback) {
    var deferred, first;
    try {
      this.errors = [];
      this.document.open();
      this.document.write(html);
      this.document.close();
    } catch (error) {
      this.emit("error", error);
    }
    first = this.errors[0];
    if (first) {
      if (callback) {
        process.nextTick(function() {
          return callback(first);
        });
      } else {
        deferred = Q.defer();
        deferred.reject(first);
        return deferred.promise;
      }
    } else {
      return this.wait(callback);
    }
  };

  Browser.prototype.__defineGetter__("location", function() {
    return this.window.location;
  });

  Browser.prototype.__defineSetter__("location", function(url) {
    return this.window.location = url;
  });

  Browser.prototype.link = function(selector) {
    var link, _i, _len, _ref;
    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (link = this.querySelector(selector)) {
      if (link.tagName === "A") {
        return link;
      }
    }
    _ref = this.querySelectorAll("body a");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      if (link.textContent.trim() === selector) {
        return link;
      }
    }
  };

  Browser.prototype.clickLink = function(selector, callback) {
    var link;
    if (!(link = this.link(selector))) {
      throw new Error("No link matching '" + selector + "'");
    }
    return this.fire("click", link, callback);
  };

  Browser.prototype.__defineGetter__("history", function() {
    return this.window.history;
  });

  Browser.prototype.back = function(callback) {
    this.window.history.back();
    return this.wait(callback);
  };

  Browser.prototype.reload = function(callback) {
    this.window.location.reload();
    return this.wait(callback);
  };

  Browser.prototype.authenticate = function(host, create) {
    var credentials, _ref;
    if (create == null) {
      create = true;
    }
    host || (host = "*");
    credentials = (_ref = this._credentials) != null ? _ref[host] : void 0;
    if (!credentials) {
      if (create) {
        credentials = new Credentials();
        this._credentials || (this._credentials = {});
        this._credentials[host] = credentials;
      } else {
        credentials = this.authenticate();
      }
    }
    return credentials;
  };

  Browser.prototype._setCredentials = function(credentials) {
    if (!credentials) {
      return;
    }
    deprecated("This credentials option is deprecated, please use browser.authenticate(host) instead.");
    switch (credentials.scheme.toLowerCase()) {
      case "basic":
        return this.authenticate().basic(credentials.user || credentials.username, credentials.password);
      case "bearer":
        return this.authenticate().bearer(credentials.token);
      case "oauth":
        return this.authenticate().oauth(credentials.token);
    }
  };

  Browser.prototype.saveHistory = function() {
    return this.window.history.save();
  };

  Browser.prototype.loadHistory = function(serialized) {
    return this.window.history.load(serialized);
  };

  Browser.prototype.field = function(selector) {
    var field, for_attr, label, _i, _len, _ref;
    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (field = this.querySelector(selector)) {
      if (field.tagName === "INPUT" || field.tagName === "TEXTAREA" || field.tagName === "SELECT") {
        return field;
      }
    }
    if (field = this.querySelector(":input[name='" + selector + "']")) {
      return field;
    }
    _ref = this.querySelectorAll("label");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      label = _ref[_i];
      if (label.textContent.trim() === selector) {
        if (for_attr = label.getAttribute("for")) {
          return this.document.getElementById(for_attr);
        } else {
          return label.querySelector(":input");
        }
      }
    }
  };

  Browser.prototype.fill = function(selector, value, callback) {
    var field;
    field = this.field(selector);
    if (!(field && (field.tagName === "TEXTAREA" || (field.tagName === "INPUT")))) {
      throw new Error("No INPUT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This INPUT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This INPUT field is readonly");
    }
    field.focus();
    field.value = value;
    this.fire("change", field, callback);
    return this;
  };

  Browser.prototype._setCheckbox = function(selector, value, callback) {
    var field;
    field = this.field(selector);
    if (!(field && field.tagName === "INPUT" && field.type === "checkbox")) {
      throw new Error("No checkbox INPUT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This INPUT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This INPUT field is readonly");
    }
    if (field.checked ^ value) {
      field.click();
    }
    if (callback) {
      this.wait(callback);
    }
    return this;
  };

  Browser.prototype.check = function(selector, callback) {
    return this._setCheckbox(selector, true, callback);
  };

  Browser.prototype.uncheck = function(selector, callback) {
    return this._setCheckbox(selector, false, callback);
  };

  Browser.prototype.choose = function(selector, callback) {
    var field;
    field = this.field(selector) || this.field("input[type=radio][value=\"" + (escape(selector)) + "\"]");
    if (!(field && field.tagName === "INPUT" && field.type === "radio")) {
      throw new Error("No radio INPUT matching '" + selector + "'");
    }
    field.click();
    if (callback) {
      this.wait(callback);
    }
    return this;
  };

  Browser.prototype._findOption = function(selector, value) {
    var field, option, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    field = this.field(selector);
    if (!(field && field.tagName === "SELECT")) {
      throw new Error("No SELECT matching '" + selector + "'");
    }
    if (field.getAttribute("disabled")) {
      throw new Error("This SELECT field is disabled");
    }
    if (field.getAttribute("readonly")) {
      throw new Error("This SELECT field is readonly");
    }
    _ref = field.options;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      option = _ref[_i];
      if (option.value === value) {
        return option;
      }
    }
    _ref1 = field.options;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      option = _ref1[_j];
      if (option.label === value) {
        return option;
      }
    }
    _ref2 = field.options;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      option = _ref2[_k];
      if (option.textContent.trim() === value) {
        return option;
      }
    }
    throw new Error("No OPTION '" + value + "'");
  };

  Browser.prototype.select = function(selector, value, callback) {
    var option;
    option = this._findOption(selector, value);
    return this.selectOption(option, callback);
  };

  Browser.prototype.selectOption = function(option, callback) {
    var select;
    if (option && !option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).value[0];
      option.setAttribute("selected", "selected");
      select.focus();
      this.fire("change", select, callback);
    } else if (callback) {
      process.nextTick(function() {
        return callback(null, false);
      });
    }
    return this;
  };

  Browser.prototype.unselect = function(selector, value, callback) {
    var option;
    option = this._findOption(selector, value);
    return this.unselectOption(option, callback);
  };

  Browser.prototype.unselectOption = function(option, callback) {
    var select;
    if (option && option.getAttribute("selected")) {
      select = this.xpath("./ancestor::select", option).value[0];
      if (!select.multiple) {
        throw new Error("Cannot unselect in single select");
      }
      option.removeAttribute("selected");
      select.focus();
      this.fire("change", select, callback);
    } else if (callback) {
      process.nextTick(function() {
        return callback(null, false);
      });
    }
    return this;
  };

  Browser.prototype.attach = function(selector, filename, callback) {
    var field, file, stat;
    field = this.field(selector);
    if (!(field && field.tagName === "INPUT" && field.type === "file")) {
      throw new Error("No file INPUT matching '" + selector + "'");
    }
    if (filename) {
      stat = FS.statSync(filename);
      file = new this.window.File();
      file.name = Path.basename(filename);
      file.type = Mime.lookup(filename);
      file.size = stat.size;
      field.files || (field.files = []);
      field.files.push(file);
      field.value = filename;
    }
    field.focus();
    this.fire("change", field, callback);
    return this;
  };

  Browser.prototype.button = function(selector) {
    var button, input, inputs, _i, _j, _k, _len, _len1, _len2, _ref;
    if (selector instanceof HTML.Element) {
      return selector;
    }
    if (button = this.querySelector(selector)) {
      if (button.tagName === "BUTTON" || button.tagName === "INPUT") {
        return button;
      }
    }
    _ref = this.querySelectorAll("button");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      button = _ref[_i];
      if (button.textContent.trim() === selector) {
        return button;
      }
    }
    inputs = this.querySelectorAll(":submit, :reset, :button");
    for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
      input = inputs[_j];
      if (input.name === selector) {
        return input;
      }
    }
    for (_k = 0, _len2 = inputs.length; _k < _len2; _k++) {
      input = inputs[_k];
      if (input.value === selector) {
        return input;
      }
    }
  };

  Browser.prototype.pressButton = function(selector, callback) {
    var button;
    if (!(button = this.button(selector))) {
      throw new Error("No BUTTON '" + selector + "'");
    }
    if (button.getAttribute("disabled")) {
      throw new Error("This button is disabled");
    }
    button.focus();
    return this.fire("click", button, callback);
  };

  Browser.prototype.focused = function() {
    return this.window._focused;
  };

  Browser.prototype.cookies = function(domain, path) {
    return this._cookies.access(domain || this.location.hostname, path || this.location.pathname);
  };

  Browser.prototype.saveCookies = function() {
    return this._cookies.save();
  };

  Browser.prototype.loadCookies = function(serialized) {
    return this._cookies.load(serialized);
  };

  Browser.prototype.localStorage = function(host) {
    return this._storages.local(host);
  };

  Browser.prototype.sessionStorage = function(host) {
    return this._storages.session(host);
  };

  Browser.prototype.saveStorage = function() {
    return this._storages.save();
  };

  Browser.prototype.loadStorage = function(serialized) {
    return this._storages.load(serialized);
  };

  Browser.prototype.evaluate = function(code, filename) {
    return this.window._evaluate(code, filename);
  };

  Browser.prototype.onalert = function(fn) {
    return this._interact.onalert(fn);
  };

  Browser.prototype.onconfirm = function(question, response) {
    return this._interact.onconfirm(question, response);
  };

  Browser.prototype.onprompt = function(message, response) {
    return this._interact.onprompt(message, response);
  };

  Browser.prototype.prompted = function(message) {
    return this._interact.prompted(message);
  };

  Browser.prototype.viewInBrowser = function(browser) {
    return require("./bcat").bcat(this.html());
  };

  Browser.prototype.__defineGetter__("lastRequest", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.request : void 0;
  });

  Browser.prototype.__defineGetter__("lastResponse", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.response : void 0;
  });

  Browser.prototype.__defineGetter__("lastError", function() {
    var _ref;
    return (_ref = this.resources.last) != null ? _ref.error : void 0;
  });

  Browser.prototype.log = function() {
    var arg, values, _i, _len;
    if (this.debug) {
      values = ["Zombie:"];
      if (typeof arguments[0] === "function") {
        try {
          values.push(arguments[0]());
        } catch (ex) {
          values.push(ex);
        }
      } else {
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          values.push(arg);
        }
      }
      return console.log.apply(null, values);
    }
  };

  Browser.prototype.dump = function() {
    var html, indent;
    indent = function(lines) {
      return lines.map(function(l) {
        return "  " + l + "\n";
      }).join("");
    };
    process.stdout.write("Zombie: " + VERSION + "\n\n");
    process.stdout.write("URL: " + this.window.location.href + "\n");
    process.stdout.write("History:\n" + (indent(this.window.history.dump())) + "\n");
    process.stdout.write("Cookies:\n" + (indent(this._cookies.dump())) + "\n");
    process.stdout.write("Storage:\n" + (indent(this._storages.dump())) + "\n");
    process.stdout.write("Eventloop:\n" + (indent(this._eventloop.dump())) + "\n");
    if (this.document) {
      html = this.document.outerHTML;
      if (html.length > 497) {
        html = html.slice(0, 497) + "...";
      }
      return process.stdout.write("Document:\n" + (indent(html.split("\n"))) + "\n");
    } else {
      if (!this.document) {
        return process.stdout.write("No document\n");
      }
    }
  };

  return Browser;

})(EventEmitter);

Credentials = (function() {

  function Credentials() {}

  Credentials.prototype.apply = function(headers) {
    var base64;
    switch (this.scheme) {
      case "basic":
        base64 = new Buffer(this.user + ":" + this.password).toString("base64");
        return headers["authorization"] = "Basic " + base64;
      case "bearer":
        return headers["authorization"] = "Bearer " + this.token;
      case "oauth":
        return headers["authorization"] = "OAuth " + this.token;
    }
  };

  Credentials.prototype.basic = function(user, password) {
    this.user = user;
    this.password = password;
    return this.scheme = "basic";
  };

  Credentials.prototype.bearer = function(token) {
    this.token = token;
    return this.scheme = "bearer";
  };

  Credentials.prototype.oauth = function(token) {
    this.token = token;
    return this.scheme = "oauth";
  };

  Credentials.prototype.reset = function() {
    delete this.scheme;
    delete this.token;
    delete this.user;
    return delete this.password;
  };

  return Credentials;

})();

Browser.VERSION = VERSION;

module.exports = Browser;
